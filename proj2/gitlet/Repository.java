package gitlet;


import java.io.File;
import java.util.*;

import static gitlet.Utils.*;

// any imports you need here

/** Represents a gitlet repository.
 *  It's a good idea to give a description here of what else this Class
 *  does at a high level.
 *
 *  @author Moksha
 */

public class Repository {
    /**
     * add instance variables here.
     *
     * List all instance variables of the Repository class here with a useful
     * comment above them describing what that variable represents and how that
     * variable is used. We've provided two examples for you.
     */

    /** The current working directory. */
    public static final File CWD = new File(System.getProperty("user.dir"));
    /** The .gitlet directory. */
    public static final File GITLET_DIR = join(CWD, ".gitlet");
    public static final File GIT_HEADS_DIR = join(GITLET_DIR, "heads");
    public static final File GIT_STAGE_AREA = join(GITLET_DIR, "index");  // Stage area.
    public static final File GIT_OBJECTS_DIR = join(GITLET_DIR, "objects");
    public static final File GIT_REMOVE_TRACK = join(GITLET_DIR, "removed_track");
    public static final File GIT_BLOB = join(GITLET_DIR, "blobs");
    public static final File GIT_BRANCH_DIR = join(GITLET_DIR, "branches");
    public static final File GIT_SHORT_ID_DIR = join(GITLET_DIR, "short_ids");
    private static TreeMap<String, String> stageArea = new TreeMap<>();  // stage area.
    private static TreeMap<String, byte[]> blobs = new TreeMap<>();  // blobs.
    private static TreeMap<String, String> removedSets = new TreeMap<>();


    /* fill in the rest of this class. */
    public static void init() {
        if (GITLET_DIR.exists()) {
            System.out.println("A Gitlet version-control system already"
                    + " exists in the current directory.");
            System.exit(0);
        }
        GITLET_DIR.mkdir();  // Create .gitlet/ directory.
        GIT_HEADS_DIR.mkdir();  // Create heads directory.
        GIT_BRANCH_DIR.mkdir();  // Create branches/ directory.

        // Read the sha-1 string value of branch head into refs/head
        File head = join(GIT_HEADS_DIR, "master");
        Commit m = new Commit("initial commit", stageArea, null, null);
        // serialize the object to byte stream and store it into master file.
        writeObject(head, m);

        // not update the commitId of master onto branches/ directory.
        File masterInBranches = join(GIT_BRANCH_DIR, "master");
        writeObject(masterInBranches, m);

        writeObject(head, m);
        String shaId = m.getOwnRef();

        GIT_OBJECTS_DIR.mkdir();
        GIT_SHORT_ID_DIR.mkdir();
        File commitObjectFile = join(GIT_OBJECTS_DIR, shaId);
        writeObject(commitObjectFile, m);  // serialize the commit to object/2id/ directory.
        writeObject(join(GIT_SHORT_ID_DIR, shaId.substring(0, 8)), m);


        // Initialize.
        writeObject(GIT_STAGE_AREA, stageArea);
        writeObject(GIT_BLOB, blobs);
        writeObject(GIT_REMOVE_TRACK, removedSets);
    }

    @SuppressWarnings("unchecked")  // ignore warning
    public static void add(String filename) {
        File in = join(CWD, filename);
        if (!in.exists()) {
            System.out.println("File does not exist.");
            System.exit(0);
        }
        // BlobId generated by fileName plus fileContents.
        String blobId = sha1(filename, readContents(in));
        // deserialize the byte stream to Commit object and align to head commit object.
        Commit head = readObject(join(GIT_HEADS_DIR, plainFilenamesIn(GIT_HEADS_DIR).get(0)),
                Commit.class);
        stageArea = readObject(GIT_STAGE_AREA, TreeMap.class);

        removedSets = readObject(GIT_REMOVE_TRACK, TreeMap.class);
        // If current added file is in the removed sets, it will not be stored in blobs.
        if (removedSets.containsKey(blobId)) {
            removedSets.remove(blobId);
            // remove blob from blobs set.
            blobs = readObject(GIT_BLOB, TreeMap.class);
            blobs.remove(blobId);
            writeObject(GIT_BLOB, blobs);
            writeObject(GIT_REMOVE_TRACK, removedSets);
        }

        /* If the current working version of the file
         is identical to the version in the current commit
         */
        if (head.getTrack().containsKey(blobId)) {
            // If the blob is contained in stage area, remove it from stage area.
            if (stageArea.containsKey(blobId)) {
                stageArea.remove(blobId);
                blobs = readObject(GIT_BLOB, TreeMap.class);
                blobs.remove(blobId);  // delete from blobs.
                writeObject(GIT_BLOB, blobs);
            }
        } else {
            //  Otherwise, add the mapping filename to blob into stage area.
            stageArea.put(blobId, filename);
            // add the Blob according to blobId into blobs.
            blobs = readObject(GIT_BLOB, TreeMap.class);
            blobs.put(blobId, readContents(in));  // Add blob into blobs.
            // update
            writeObject(GIT_BLOB, blobs);
        }
        // Write back to .gitlet/stage file.
        writeObject(GIT_STAGE_AREA, stageArea);
    }

    @SuppressWarnings("unchecked")  // ignore warning
    public static void commit(String message) {
        // Read removed set.
        removedSets = readObject(GIT_REMOVE_TRACK, TreeMap.class);
        // Read stage.
        stageArea = readObject(GIT_STAGE_AREA, TreeMap.class);
        // Current branch name.
        String currentBranchName = plainFilenamesIn(GIT_HEADS_DIR).get(0);
        // If no files have been staged, print message and abort.
        if (stageArea.isEmpty() && removedSets.isEmpty()) {
            System.out.println("No changes added to the commit.");
            System.exit(0);
        }
        if (message.isBlank()) {
            System.out.println("Please enter a commit message.");
            return;
        }

        Commit newCommit = new Commit(message, stageArea, null, null);
        Commit head = readObject(join(GIT_HEADS_DIR, currentBranchName), Commit.class);

        // Add the previous commit tracks into current commit.
//        newCommit.addPreviousCommitTrack(head.getTrack());

        // If removed set is not empty, remove from current Commit. And then clear it.
        if (!removedSets.isEmpty()) {
            newCommit.removeTracks(removedSets);
            removedSets.clear();
            // Update removed set.
            writeObject(GIT_REMOVE_TRACK, removedSets);
        }

        newCommit.setParentRef(head.getOwnRef());  // set current commit as the new commit parent.
        // update master Object then write back to heads directory.
        head = newCommit;

        // update head commit file(head pointer).
        writeObject(join(GIT_HEADS_DIR, currentBranchName), head);

        // add commit object to object file.
        String shaId = newCommit.getOwnRef();
        writeObject(join(GIT_OBJECTS_DIR, shaId), newCommit);
        writeObject(join(GIT_SHORT_ID_DIR, shaId.substring(0, 8)), newCommit);
        // Clear stage area after commit.
        stageArea.clear();
        // update stage area.
        writeObject(GIT_STAGE_AREA, stageArea);
    }

    @SuppressWarnings("unchecked")  // ignore warning
    public static void rm(String filename) {
        stageArea = readObject(GIT_STAGE_AREA, TreeMap.class);
        blobs = readObject(GIT_BLOB, TreeMap.class);
        Commit head = readObject(join(GIT_HEADS_DIR, plainFilenamesIn(GIT_HEADS_DIR).get(0)),
                Commit.class);
        Map<String, String> tracks = head.getTrack();

        // If the file currently in the stage area.
        if (stageArea.containsValue(filename)) {
            for (Map.Entry<String, String> entry : stageArea.entrySet()) {
                // entry.getValue() get filename.
                if (entry.getValue().equals(filename)) {
                    // entry.getKey() get the concrete blobId.
                    stageArea.remove(entry.getKey());  // Remove the blob from stage area.
                }
            }
        } else {
            /* If the file is neither tracked by the head commit nor stage in stage area.
            Print error message.
            */
            if (!head.getTrack().containsValue(filename)) {
                System.out.println("No reason to remove the file.");
                System.exit(0);
            } else {  // tracked
                removedSets = readObject(GIT_REMOVE_TRACK, TreeMap.class);
                for (Map.Entry<String, String> entry : tracks.entrySet()) {
                    // add track to the list to be removed.
                    if (entry.getValue().equals(filename)) {
                        removedSets.put(entry.getKey(), filename);
                        writeObject(GIT_REMOVE_TRACK, removedSets);
                        // Do not remove it unless it is tracked in the current commit.
                        restrictedDelete(join(CWD, filename));  // delete file
                    }
                }
            }
        }
        // update stageArea.
        writeObject(GIT_STAGE_AREA, stageArea);
    }

    public static void log() {
        Commit head = readObject(join(GIT_HEADS_DIR, plainFilenamesIn(GIT_HEADS_DIR).get(0)),
                Commit.class);
        while (true) {
            System.out.println("===");
            System.out.println("commit " + head.getOwnRef());
            System.out.println("Date: " + head.getTimeStamp());
            System.out.println(head.getMessage());
            System.out.println();
            String shaId = head.getParentRef();
            // If parent of current commit object not exist, quit print log.
            if (shaId == null) {
                break;
            }
            File commitObjectFile = join(GIT_OBJECTS_DIR, shaId);
            head = readObject(commitObjectFile, Commit.class);
        }
    }

    public static void globalLog() {
        List<String> commitList = plainFilenamesIn(GIT_OBJECTS_DIR);
        for (String commitId : commitList) {
            // Get commit object.
            Commit m = readObject(join(GIT_OBJECTS_DIR, commitId), Commit.class);
            System.out.println("===");
            System.out.println("commit " + m.getOwnRef());
            System.out.println("Date: " + m.getTimeStamp());
            System.out.println(m.getMessage());
            System.out.println();
        }
    }

    public static void find(String commitMessage) {
        List<String> commitList = plainFilenamesIn(GIT_OBJECTS_DIR);
        boolean exist = false;
        for (String commitId : commitList) {
            // Get commit object.
            Commit m = readObject(join(GIT_OBJECTS_DIR, commitId), Commit.class);
            if (m.getMessage().equals(commitMessage)) {
                System.out.println(m.getOwnRef());
                exist = true;
            }
        }
        if (!exist) {
            System.out.println("Found no commit with that message.");
        }
    }

    @SuppressWarnings("unchecked")  // ignore warning
    public static void status() {
        System.out.println("=== Branches ===");
        // plainFilesIn function return lexicographic order.
        List<String> branches = plainFilenamesIn(GIT_BRANCH_DIR);
        String currentBranchName = plainFilenamesIn(GIT_HEADS_DIR).get(0);
        for (String branchName : branches) {
            // If head.
            if (currentBranchName.equals(branchName)) {
                System.out.println("*" + branchName);
            } else {
                System.out.println(branchName);
            }
        }
        System.out.println();

        System.out.println("=== Staged Files ===");
        stageArea = readObject(GIT_STAGE_AREA, TreeMap.class);
        for (Map.Entry<String, String> entry : stageArea.entrySet()) {
            // Print filename.
            System.out.println(entry.getValue());
        }
        System.out.println();

        System.out.println("=== Removed Files ===");
        removedSets = readObject(GIT_REMOVE_TRACK, TreeMap.class);
        for (Map.Entry<String, String> entry : removedSets.entrySet()) {
            // Print filename.
            System.out.println(entry.getValue());
        }
        System.out.println();

        List<String> filesInDir = plainFilenamesIn(CWD);
        // Get current commit tracks.
        Commit headCommit = readObject(join(GIT_HEADS_DIR, plainFilenamesIn(GIT_HEADS_DIR).get(0)),
                Commit.class);
        TreeMap<String, String> tracks = headCommit.getTrack();
        // TODO add "Modifications Not Staged For Commit" and "Untracked Files" information.
        System.out.println("=== Modifications Not Staged For Commit ===");
        System.out.println();

        System.out.println("=== Untracked Files ===");
//        blobs = readObject(GIT_BLOB, TreeMap.class);
//        for (String fileName : filesInDir) {
//            File concreteFile = join(CWD, fileName);
//            // Untracked file will be written.
//            String blobId = sha1(fileName, readContents(concreteFile));
//            // If commit not track and not add this file to stage area.
//            if (!(blobs.containsKey(blobId) || stageArea.containsKey(blobId))) {
//                System.out.println(fileName);
//            }
//        }
        System.out.println();
    }

    @SuppressWarnings("unchecked")  // ignore warning
    public static void checkout(String[] args) {
        String currentBranchName = plainFilenamesIn(GIT_HEADS_DIR).get(0);
        Commit currCommit = readObject(join(GIT_HEADS_DIR, currentBranchName), Commit.class);
        TreeMap<String, String> tracks = currCommit.getTrack();
        List<String> branches = plainFilenamesIn(GIT_BRANCH_DIR);
        // Get the tracked file of head commit object.
        stageArea = readObject(GIT_STAGE_AREA, TreeMap.class);
        blobs = readObject(GIT_BLOB, TreeMap.class);

        // checkout -- fileName
        if (args.length == 3) {
            String fileName = args[2];
            if (!args[1].equals("--")) {
                System.out.println("Incorrect operands.");
                System.exit(0);
            }

            // if file not in current commit.
            if (!tracks.containsValue(fileName)) {
                System.out.println("File does not exist in that commit.");
                System.exit(0);
            }


            /* Traverse one file tracked by this commit to find the blobId
            corresponding to the filename.
             */
            for (Map.Entry<String, String> entry : tracks.entrySet()) {
                if (entry.getValue().equals(fileName)) {
                    byte[] fileContentTrackedByCommit = blobs.get(entry.getKey());
                    writeContents(join(CWD, fileName), fileContentTrackedByCommit);
                }
            }

        // checkout commitId -- fileName
        } else if (args.length == 4) {
            String commitId = args[1];
            String fileName = args[3];

            if (!args[2].equals("--")) {
                System.out.println("Incorrect operands.");
                System.exit(0);
            }

            List<String> commitIdNames = plainFilenamesIn(GIT_OBJECTS_DIR);
            List<String> shortIdNames = plainFilenamesIn(GIT_SHORT_ID_DIR);
            // If current commit tracks do not contain the commit id, print message.
            if (!commitIdNames.contains(commitId) && !shortIdNames.contains(commitId)) {
                System.out.println("No commit with that id exists.");
                System.exit(0);
            }

            // if file not in current commit.
            if (!tracks.containsValue(fileName)) {
                System.out.println("File does not exist in that commit.");
                System.exit(0);
            }

            Commit concreteCommit;
            if (commitId.length() <= 8) {
                // ShortId version.
                concreteCommit = readObject(join(GIT_SHORT_ID_DIR, commitId), Commit.class);
            } else {
                concreteCommit = readObject(join(GIT_OBJECTS_DIR, commitId), Commit.class);
            }
            // Get the Commit object resides in commit which id is commitId.
            TreeMap<String, String> conTracks = concreteCommit.getTrack();

            /* Traverse one file tracked by this commit to find the blobId
            corresponding to the filename.
             */
            for (Map.Entry<String, String> entry : conTracks.entrySet()) {
                if (entry.getValue().equals(fileName)) {
                    byte[] fileContentTrackedByCommit = blobs.get(entry.getKey());
                    writeContents(join(CWD, fileName), fileContentTrackedByCommit);
                }
            }

        // checkout branchName
        } else if (args.length == 2) {
            String branchName = args[1];

            // actually, current directory is not current commit resided directory.
            List<String> currentDirFileNames = plainFilenamesIn(CWD);
            // Do not exist such a branch in branch directory, print message.
            if (!branches.contains(branchName)) {
                System.out.println("No such branch exists.");
                System.exit(0);
            }

            if (currentBranchName.equals(branchName)) {
                System.out.println("no need to checkout the current branch.");
                System.exit(0);
            }

            Commit checkoutBranch = readObject(join(GIT_BRANCH_DIR, branchName), Commit.class);
            TreeMap<String, String> checkoutTracks = checkoutBranch.getTrack();

            // Traverse current directory files.
            for (String fileName : currentDirFileNames) {
                File concreteFile = join(CWD, fileName);
                // Untracked file will be written.
                String blobId = sha1(fileName, readContents(concreteFile));
                if (!(blobs.containsKey(blobId) || stageArea.containsKey(blobId))) {
                    System.out.println("There is an untracked file in the way; "
                            + "delete it, or add and commit it first.");
                    System.exit(0);
                }
                // TODO
                if (!checkoutTracks.containsValue(fileName)) {
                    restrictedDelete(concreteFile);
                }
            }

            /* Traverse files tracked by this commit to find the blobId
            corresponding to the filename.
             */
            for (Map.Entry<String, String> entry : checkoutTracks.entrySet()) {
                String fileName = entry.getValue();
                byte[] fileContentTrackedByCommit = blobs.get(entry.getKey());
                writeContents(join(CWD, fileName), fileContentTrackedByCommit);
            }

            // read the current head to update corresponding branch.
            Commit head = readObject(join(GIT_HEADS_DIR, currentBranchName), Commit.class);
            // Update branch information in branches/ dir.
            writeObject(join(GIT_BRANCH_DIR, currentBranchName), head);

            Commit branchToBeChanged = readObject(join(GIT_BRANCH_DIR, branchName), Commit.class);
            // set the branch parameter as the head branch(e.g. head pointer).
            writeObject(join(GIT_HEADS_DIR, branchName), branchToBeChanged);

            // Delete current branch file from heads/ dir.
            join(GIT_HEADS_DIR, currentBranchName).delete();

            // clear stage Area after branch checkout.
            stageArea = readObject(GIT_STAGE_AREA, TreeMap.class);
            stageArea.clear();
            writeObject(GIT_STAGE_AREA, stageArea);
        }
    }

    public static void branch(String branchName) {
        List<String> branchNames = plainFilenamesIn(GIT_BRANCH_DIR);
        if (branchNames.contains(branchName)) {
            System.out.println("A branch with that name already exists.");
            System.exit(0);
        }
        String currentBranchName = plainFilenamesIn(GIT_HEADS_DIR).get(0);
        // read the current head to update corresponding branch.
        Commit head = readObject(join(GIT_HEADS_DIR, currentBranchName), Commit.class);
        // Update branch information in branches/ dir.
//        writeObject(join(GIT_BRANCH_DIR, currentBranchName), head);

//        Commit newBranch = head;
        // create new branch.
        writeObject(join(GIT_BRANCH_DIR, branchName), head);
    }

    public static void rmBranch(String branchName) {
        List<String> branchNames = plainFilenamesIn(GIT_BRANCH_DIR);
        String currentBranchName = plainFilenamesIn(GIT_HEADS_DIR).get(0);
        if (!branchNames.contains(branchName)) {
            System.out.println("A branch with that name does not exist.");
            System.exit(0);
        }
        if (branchName.equals(currentBranchName)) {
            System.out.println("Cannot remove the current branch.");
            System.exit(0);
        }
        // Delete branch.
        join(GIT_BRANCH_DIR, branchName).delete();
    }

    @SuppressWarnings("unchecked")  // ignore warning
    public static void reset(String commitId) {
        List<String> commitIds = plainFilenamesIn(GIT_OBJECTS_DIR);
        String currentBranchName = plainFilenamesIn(GIT_BRANCH_DIR).get(0);
        stageArea = readObject(GIT_STAGE_AREA, TreeMap.class);
        blobs = readObject(GIT_BLOB, TreeMap.class);
        if (!commitIds.contains(commitId)) {
            System.out.println("No commit with that id exists.");
            System.exit(0);
        }
        Commit concreteCommit = readObject(join(GIT_OBJECTS_DIR, commitId), Commit.class);
        TreeMap<String, String> tracks = concreteCommit.getTrack();
        List<String> currentDirFileNames = plainFilenamesIn(CWD);

        // Traverse current directory files.
        for (String fileName : currentDirFileNames) {
            File concreteFile = join(CWD, fileName);
            // Untracked file will be written.
            String blobId = sha1(fileName, readContents(concreteFile));
            if (!(blobs.containsKey(blobId) || stageArea.containsKey(blobId))) {
                System.out.println("There is an untracked file in the way;"
                        + "delete it, or add and commit it first.");
                System.exit(0);
            }
            // TODO
            if (!tracks.containsValue(fileName)) {
                /* delete files of current directory
                that does not be tracked by the to be reset commit.
                 */
                restrictedDelete(concreteFile);
            }
        }

        /* Traverse files tracked by this commit to find the blobId
        corresponding to the filename and write file.
         */
        for (Map.Entry<String, String> entry : tracks.entrySet()) {
            String fileName = entry.getValue();
            byte[] fileContentTrackedByCommit = blobs.get(entry.getKey());
            writeContents(join(CWD, fileName), fileContentTrackedByCommit);
        }

        /* Rollback branches, then update the branch
        serialized file in heads/ dir and branches/ dir.
         */
        writeObject(join(GIT_HEADS_DIR, currentBranchName), concreteCommit);
        writeObject(join(GIT_BRANCH_DIR, currentBranchName), concreteCommit);

        // clear stage Area after branch checkout.
        stageArea = readObject(GIT_STAGE_AREA, TreeMap.class);
        stageArea.clear();
        writeObject(GIT_STAGE_AREA, stageArea);
    }


}

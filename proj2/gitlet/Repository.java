package gitlet;



import java.io.File;
import java.util.TreeMap;
import java.util.Map;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.HashSet;
import java.util.Set;
import java.util.Queue;

import static gitlet.Utils.*;

// any imports you need here

/** Represents a gitlet repository.
 *  It's a good idea to give a description here of what else this Class
 *  does at a high level.
 *
 *  @author Moksha
 */

public class Repository {
    /**
     * add instance variables here.
     *
     * List all instance variables of the Repository class here with a useful
     * comment above them describing what that variable represents and how that
     * variable is used. We've provided two examples for you.
     */

    /** The current working directory. */
    public static final File CWD = new File(System.getProperty("user.dir"));
    /** The .gitlet directory. */
    public static final File GITLET_DIR = join(CWD, ".gitlet");
    public static final File GIT_HEADS_DIR = join(GITLET_DIR, "heads");
    public static final File GIT_STAGE_FOR_ADD = join(GITLET_DIR, "stage_for_add");  // Stage area.
    public static final File GIT_OBJECTS_DIR = join(GITLET_DIR, "objects");
    public static final File GIT_STAGE_FOR_REMOVE = join(GITLET_DIR, "stage_for_remove");
    public static final File GIT_BLOB = join(GITLET_DIR, "blobs");
    public static final File GIT_BRANCH_DIR = join(GITLET_DIR, "branches");
    public static final File GIT_SHORT_ID_DIR = join(GITLET_DIR, "short_ids");
    private static TreeMap<String, String> stageForAddition = new TreeMap<>();  // stage area.
    private static TreeMap<String, byte[]> blobs = new TreeMap<>();  // blobs.
    private static TreeMap<String, String> stageForRemoval = new TreeMap<>();


    /* fill in the rest of this class. */
    public static void init() {
        if (GITLET_DIR.exists()) {
            System.out.println("A Gitlet version-control system already"
                    + " exists in the current directory.");
            System.exit(0);
        }
        GITLET_DIR.mkdir();  // Create .gitlet/ directory.
        GIT_HEADS_DIR.mkdir();  // Create heads directory.
        GIT_BRANCH_DIR.mkdir();  // Create branches/ directory.

        // Read the sha-1 string value of branch head into refs/head
        File head = join(GIT_HEADS_DIR, "master");
        Commit m = new Commit("initial commit", stageForAddition, null, null);
        // serialize the object to byte stream and store it into master file.
        writeObject(head, m);

        // not update the commitId of master onto branches/ directory.
        File masterInBranches = join(GIT_BRANCH_DIR, "master");
        writeObject(masterInBranches, m);

        writeObject(head, m);
        String shaId = m.getOwnRef();

        GIT_OBJECTS_DIR.mkdir();
        GIT_SHORT_ID_DIR.mkdir();
        File commitObjectFile = join(GIT_OBJECTS_DIR, shaId);
        writeObject(commitObjectFile, m);  // serialize the commit to object/2id/ directory.
        writeObject(join(GIT_SHORT_ID_DIR, shaId.substring(0, 8)), m);


        // Initialize.
        writeObject(GIT_STAGE_FOR_ADD, stageForAddition);
        writeObject(GIT_BLOB, blobs);
        writeObject(GIT_STAGE_FOR_REMOVE, stageForRemoval);
    }

    @SuppressWarnings("unchecked")  // ignore warning
    public static void add(String filename) {
        File in = join(CWD, filename);
        if (!in.exists()) {
            System.out.println("File does not exist.");
            System.exit(0);
        }
        // BlobId generated by fileName plus fileContents.
        String blobId = sha1(filename, readContents(in));
        // deserialize the byte stream to Commit object and align to head commit object.
        Commit head = readObject(join(GIT_HEADS_DIR, plainFilenamesIn(GIT_HEADS_DIR).get(0)),
                Commit.class);
        stageForAddition = readObject(GIT_STAGE_FOR_ADD, TreeMap.class);

        stageForRemoval = readObject(GIT_STAGE_FOR_REMOVE, TreeMap.class);
        // If current added file is in the removed sets, it will not be stored for removal.
        if (stageForRemoval.containsKey(blobId)) {
            stageForRemoval.remove(blobId);
            writeObject(GIT_STAGE_FOR_REMOVE, stageForRemoval);
        }

        /* If the current working version of the file
         is identical to the version in the current commit
         */
        if (head.getTrack().containsKey(blobId)) {
            // If the blob is contained in stage area, remove it from stage area.
            if (stageForAddition.containsKey(blobId)) {
                stageForAddition.remove(blobId);
            }
        } else {
            //  Otherwise, add the mapping filename to blob into stage area.
            stageForAddition.put(blobId, filename);
            // add the Blob according to blobId into blobs.
            blobs = readObject(GIT_BLOB, TreeMap.class);
            blobs.put(blobId, readContents(in));  // Add blob into blobs.
            // update
            writeObject(GIT_BLOB, blobs);
        }
        // Write back to .gitlet/stage file.
        writeObject(GIT_STAGE_FOR_ADD, stageForAddition);
    }

    @SuppressWarnings("unchecked")  // ignore warning
    public static void commit(String message) {
        commitMerge(message, null);
    }

    @SuppressWarnings("unchecked")  // ignore warning
    public static void commitMerge(String message, String secondParentRef) {
        // Read removed set.
        stageForRemoval = readObject(GIT_STAGE_FOR_REMOVE, TreeMap.class);
        // Read stage.
        stageForAddition = readObject(GIT_STAGE_FOR_ADD, TreeMap.class);
        // Current branch name.
        String currentBranchName = plainFilenamesIn(GIT_HEADS_DIR).get(0);
        // If no files have been staged, print message and abort.
        if (stageForAddition.isEmpty() && stageForRemoval.isEmpty()) {
            System.out.println("No changes added to the commit.");
            System.exit(0);
        }
        if (message.isBlank()) {
            System.out.println("Please enter a commit message.");
            return;
        }

        Commit newCommit = new Commit(message, stageForAddition, null, secondParentRef);
        Commit head = readObject(join(GIT_HEADS_DIR, currentBranchName), Commit.class);

        // Add the previous commit tracks current commit doesn't have into current commit.
        newCommit.addPreviousCommitTrack(head.getTrack(), newCommit.getTrack());

        // If removed set is not empty, remove from current Commit. And then clear it.
        if (!stageForRemoval.isEmpty()) {
            newCommit.removeTracks(stageForRemoval);
        }

        newCommit.setParentRef(head.getOwnRef());  // set current commit as the new commit parent.
        // update master Object then write back to heads directory.
        head = newCommit;

        // update head commit file(head pointer).
        writeObject(join(GIT_HEADS_DIR, currentBranchName), head);
        // update head commit in branches dir.
        writeObject(join(GIT_BRANCH_DIR, currentBranchName), head);

        // add commit object to object file.
        String shaId = newCommit.getOwnRef();
        writeObject(join(GIT_OBJECTS_DIR, shaId), newCommit);
        writeObject(join(GIT_SHORT_ID_DIR, shaId.substring(0, 8)), newCommit);

        // Clear stage area after commit.
        stageForAddition.clear();
        // update stage area.
        writeObject(GIT_STAGE_FOR_ADD, stageForAddition);
        stageForRemoval.clear();
        // Update removed set.
        writeObject(GIT_STAGE_FOR_REMOVE, stageForRemoval);
    }

    @SuppressWarnings("unchecked")  // ignore warning
    public static void rm(String filename) {
        stageForAddition = readObject(GIT_STAGE_FOR_ADD, TreeMap.class);
        blobs = readObject(GIT_BLOB, TreeMap.class);
        Commit head = readObject(join(GIT_HEADS_DIR, plainFilenamesIn(GIT_HEADS_DIR).get(0)),
                Commit.class);
        TreeMap<String, String> tracks = head.getTrack();

        // If the file currently in the stage area.
        if (stageForAddition.containsValue(filename)) {
            for (Map.Entry<String, String> entry : stageForAddition.entrySet()) {
                // entry.getValue() get filename.
                if (entry.getValue().equals(filename)) {
                    // entry.getKey() get the concrete blobId.
                    stageForAddition.remove(entry.getKey());  // Remove the blob from stage area.
                }
            }
        } else {
            /* If the file is neither tracked by the head commit nor stage in stage area.
            Print error message.
            */
            if (!tracks.containsValue(filename)) {
                System.out.println("No reason to remove the file.");
                System.exit(0);
            } else {  // tracked
                stageForRemoval = readObject(GIT_STAGE_FOR_REMOVE, TreeMap.class);
                for (Map.Entry<String, String> entry : tracks.entrySet()) {
                    // add track to the list to be removed.
                    if (entry.getValue().equals(filename)) {
                        stageForRemoval.put(entry.getKey(), filename);
                        writeObject(GIT_STAGE_FOR_REMOVE, stageForRemoval);
                        // Do not remove it unless it is tracked in the current commit.
                        restrictedDelete(join(CWD, filename));  // delete file
                    }
                }
            }
        }
        // update stageForAddition.
        writeObject(GIT_STAGE_FOR_ADD, stageForAddition);
    }

    public static void log() {
        Commit head = readObject(join(GIT_HEADS_DIR, plainFilenamesIn(GIT_HEADS_DIR).get(0)),
                Commit.class);
        while (true) {
            System.out.println("===");
            System.out.println("commit " + head.getOwnRef());
            System.out.println("Date: " + head.getTimeStamp());
            System.out.println(head.getMessage());
            System.out.println();
            String shaId = head.getParentRef();
            // If parent of current commit object not exist, quit print log.
            if (shaId == null) {
                break;
            }
            File commitObjectFile = join(GIT_OBJECTS_DIR, shaId);
            head = readObject(commitObjectFile, Commit.class);
        }
    }

    public static void globalLog() {
        List<String> commitList = plainFilenamesIn(GIT_OBJECTS_DIR);
        for (String commitId : commitList) {
            // Get commit object.
            Commit m = readObject(join(GIT_OBJECTS_DIR, commitId), Commit.class);
            System.out.println("===");
            System.out.println("commit " + m.getOwnRef());
            System.out.println("Date: " + m.getTimeStamp());
            System.out.println(m.getMessage());
            System.out.println();
        }
    }

    public static void find(String commitMessage) {
        List<String> commitList = plainFilenamesIn(GIT_OBJECTS_DIR);
        boolean exist = false;
        for (String commitId : commitList) {
            // Get commit object.
            Commit m = readObject(join(GIT_OBJECTS_DIR, commitId), Commit.class);
            if (m.getMessage().equals(commitMessage)) {
                System.out.println(m.getOwnRef());
                exist = true;
            }
        }
        if (!exist) {
            System.out.println("Found no commit with that message.");
        }
    }

    @SuppressWarnings("unchecked")  // ignore warning
    public static void status() {
        System.out.println("=== Branches ===");
        // plainFilesIn function return lexicographic order.
        List<String> branches = plainFilenamesIn(GIT_BRANCH_DIR);
        String currentBranchName = plainFilenamesIn(GIT_HEADS_DIR).get(0);
        for (String branchName : branches) {
            // If head.
            if (currentBranchName.equals(branchName)) {
                System.out.println("*" + branchName);
            } else {
                System.out.println(branchName);
            }
        }
        System.out.println();

        System.out.println("=== Staged Files ===");
        stageForAddition = readObject(GIT_STAGE_FOR_ADD, TreeMap.class);
        for (Map.Entry<String, String> entry : stageForAddition.entrySet()) {
            // Print filename.
            System.out.println(entry.getValue());
        }
        System.out.println();

        System.out.println("=== Removed Files ===");
        stageForRemoval = readObject(GIT_STAGE_FOR_REMOVE, TreeMap.class);
        for (Map.Entry<String, String> entry : stageForRemoval.entrySet()) {
            // Print filename.
            System.out.println(entry.getValue());
        }
        System.out.println();

        List<String> filesInDir = plainFilenamesIn(CWD);
        // Get current commit tracks.
        Commit headCommit = readObject(join(GIT_HEADS_DIR, plainFilenamesIn(GIT_HEADS_DIR).get(0)),
                Commit.class);
        TreeMap<String, String> tracks = headCommit.getTrack();
        // TODO add "Modifications Not Staged For Commit" and "Untracked Files" information.
        System.out.println("=== Modifications Not Staged For Commit ===");
        for (Map.Entry<String, String> entry : tracks.entrySet()) {
            File f = join(CWD, entry.getValue());
            if (!f.exists() && !stageForRemoval.containsKey(entry.getKey())) {
                System.out.println(entry.getValue() + " (deleted)");
            }
        }
        for (String fileName : filesInDir) {
            byte[] contents = readContents(join(CWD, fileName));
            String blobId = sha1(fileName, contents);
            for (Map.Entry<String, String> entry : tracks.entrySet()) {
                if (entry.getValue().equals(fileName)
                    && !entry.getKey().equals(blobId)) {
                    // modified
                    System.out.println(fileName + " (modified)");
                }
            }
        }
        System.out.println();
        System.out.println("=== Untracked Files ===");
        blobs = readObject(GIT_BLOB, TreeMap.class);
        for (String fileName : filesInDir) {
            File concreteFile = join(CWD, fileName);
            // Untracked file will be written.
            String blobId = sha1(fileName, readContents(concreteFile));
            // If commit not track and not add this file to stage area.
            if (!(blobs.containsKey(blobId) || stageForAddition.containsKey(blobId)
                || tracks.containsValue(fileName))) {
                System.out.println(fileName);
            }
        }
        System.out.println();
    }

    @SuppressWarnings("unchecked")  // ignore warning
    public static void checkout(String[] args) {
        String currentBranchName = plainFilenamesIn(GIT_HEADS_DIR).get(0);
        Commit currCommit = readObject(join(GIT_HEADS_DIR, currentBranchName), Commit.class);
        TreeMap<String, String> tracks = currCommit.getTrack();
        List<String> branches = plainFilenamesIn(GIT_BRANCH_DIR);
        // Get the tracked file of head commit object.
        stageForAddition = readObject(GIT_STAGE_FOR_ADD, TreeMap.class);
        blobs = readObject(GIT_BLOB, TreeMap.class);
        if (args.length == 3) {  // checkout -- fileName
            String fileName = args[2];
            if (!args[1].equals("--")) {
                System.out.println("Incorrect operands.");
                System.exit(0);
            }
            changeWorkingDirectory(tracks, fileName);
        } else if (args.length == 4) {  // checkout commitId -- fileName
            String commitId = args[1];
            String fileName = args[3];
            if (!args[2].equals("--")) {
                System.out.println("Incorrect operands.");
                System.exit(0);
            }
            List<String> commitIdNames = plainFilenamesIn(GIT_OBJECTS_DIR);
            List<String> shortIdNames = plainFilenamesIn(GIT_SHORT_ID_DIR);
            // If current commit tracks do not contain the commit id, print message.
            if (!commitIdNames.contains(commitId) && !shortIdNames.contains(commitId)) {
                System.out.println("No commit with that id exists.");
                System.exit(0);
            }
            printNotExistMessage(tracks, fileName);
            Commit concreteCommit;
            if (commitId.length() <= 8) {
                // ShortId version.
                concreteCommit = readObject(join(GIT_SHORT_ID_DIR, commitId), Commit.class);
            } else {
                concreteCommit = readObject(join(GIT_OBJECTS_DIR, commitId), Commit.class);
            }
            // Get the Commit object resides in commit which id is commitId.
            TreeMap<String, String> conTracks = concreteCommit.getTrack();
            changeWorkingDirectory(conTracks, fileName);
        } else if (args.length == 2) {  // checkout branchName
            String branchName = args[1];
            // actually, current directory is not current commit resided directory.
            List<String> currentDirFileNames = plainFilenamesIn(CWD);
            // Do not exist such a branch in branch directory, print message.
            if (!branches.contains(branchName)) {
                System.out.println("No such branch exists.");
                System.exit(0);
            }
            if (currentBranchName.equals(branchName)) {
                System.out.println("no need to checkout the current branch.");
                System.exit(0);
            }
            Commit checkoutBranch = readObject(join(GIT_BRANCH_DIR, branchName), Commit.class);
            TreeMap<String, String> checkoutTracks = checkoutBranch.getTrack();
            // Traverse current directory files.
            for (String fileName : currentDirFileNames) {
                File concreteFile = join(CWD, fileName);
                // Untracked file will be written.
                String blobId = sha1(fileName, readContents(concreteFile));
                if (!(blobs.containsKey(blobId) || stageForAddition.containsKey(blobId))) {
                    System.out.println("There is an untracked file in the way; "
                            + "delete it, or add and commit it first.");
                    System.exit(0);
                }
                if (!checkoutTracks.containsValue(fileName)) {
                    restrictedDelete(concreteFile);
                }
            }
            // update files in working directory.
            for (Map.Entry<String, String> entry : checkoutTracks.entrySet()) {
                String fileName = entry.getValue();
                byte[] fileContentTrackedByCommit = blobs.get(entry.getKey());
                writeContents(join(CWD, fileName), fileContentTrackedByCommit);
            }
            branchSwitch(branchName, currentBranchName);
            clearstageForAddition();
        }
    }

    public static void branchSwitch(String branchName, String currentBranchName) {
        // read the current head to update corresponding branch.
        Commit head = readObject(join(GIT_HEADS_DIR, currentBranchName), Commit.class);
        // Update branch information in branches/ dir.
//        writeObject(join(GIT_BRANCH_DIR, currentBranchName), head);
        Commit branchToBeChanged = readObject(join(GIT_BRANCH_DIR, branchName), Commit.class);
        // set the branch parameter as the head branch(e.g. head pointer).
        writeObject(join(GIT_HEADS_DIR, branchName), branchToBeChanged);
        // Delete current branch file from heads/ dir.
        join(GIT_HEADS_DIR, currentBranchName).delete();
    }

    public static void changeWorkingDirectory(TreeMap<String, String> tracks, String fileName) {
        /* Traverse one file tracked by this commit to find the blobId
        corresponding to the filename.
         */
        for (Map.Entry<String, String> entry : tracks.entrySet()) {
            if (entry.getValue().equals(fileName)) {
                byte[] fileContentTrackedByCommit = blobs.get(entry.getKey());
                writeContents(join(CWD, fileName), fileContentTrackedByCommit);
            }
        }
    }

    public static void printNotExistMessage(TreeMap<String, String> tracks, String fileName) {
        // if file not in current commit.
        if (!tracks.containsValue(fileName)) {
            System.out.println("File does not exist in that commit.");
            System.exit(0);
        }
    }

    @SuppressWarnings("unchecked")  // ignore warning
    public static void clearstageForAddition() {
        // clear stage Area after branch checkout.
        stageForAddition = readObject(GIT_STAGE_FOR_ADD, TreeMap.class);
        stageForAddition.clear();
        writeObject(GIT_STAGE_FOR_ADD, stageForAddition);
    }

    public static void branch(String branchName) {
        List<String> branchNames = plainFilenamesIn(GIT_BRANCH_DIR);
        if (branchNames.contains(branchName)) {
            System.out.println("A branch with that name already exists.");
            System.exit(0);
        }
        String currentBranchName = plainFilenamesIn(GIT_HEADS_DIR).get(0);
        // read the current head to update corresponding branch.
        Commit head = readObject(join(GIT_HEADS_DIR, currentBranchName), Commit.class);
        // create new branch.
        writeObject(join(GIT_BRANCH_DIR, branchName), head);
    }

    public static void rmBranch(String branchName) {
        List<String> branchNames = plainFilenamesIn(GIT_BRANCH_DIR);
        String currentBranchName = plainFilenamesIn(GIT_HEADS_DIR).get(0);
        if (!branchNames.contains(branchName)) {
            System.out.println("A branch with that name does not exist.");
            System.exit(0);
        }
        if (branchName.equals(currentBranchName)) {
            System.out.println("Cannot remove the current branch.");
            System.exit(0);
        }
        // Delete branch.
        join(GIT_BRANCH_DIR, branchName).delete();
    }

    @SuppressWarnings("unchecked")  // ignore warning
    public static void reset(String commitId) {
        List<String> commitIds = plainFilenamesIn(GIT_OBJECTS_DIR);
        String currentBranchName = plainFilenamesIn(GIT_BRANCH_DIR).get(0);
        stageForAddition = readObject(GIT_STAGE_FOR_ADD, TreeMap.class);
        blobs = readObject(GIT_BLOB, TreeMap.class);
        if (!commitIds.contains(commitId)) {
            System.out.println("No commit with that id exists.");
            System.exit(0);
        }
        Commit concreteCommit = readObject(join(GIT_OBJECTS_DIR, commitId), Commit.class);
        TreeMap<String, String> tracks = concreteCommit.getTrack();
        List<String> currentDirFileNames = plainFilenamesIn(CWD);

        // Traverse current directory files.
        for (String fileName : currentDirFileNames) {
            File concreteFile = join(CWD, fileName);
            // Untracked file will be written.
            String blobId = sha1(fileName, readContents(concreteFile));
            if (!(blobs.containsKey(blobId) || stageForAddition.containsKey(blobId))) {
                System.out.println("There is an untracked file in the way;"
                        + "delete it, or add and commit it first.");
                System.exit(0);
            }
            if (!tracks.containsValue(fileName)) {
                /* delete files of current directory
                that does not be tracked by the to be reset commit.
                 */
                restrictedDelete(concreteFile);
            }
        }

        /* Traverse files tracked by this commit to find the blobId
        corresponding to the filename and write file.
         */
        for (Map.Entry<String, String> entry : tracks.entrySet()) {
            String fileName = entry.getValue();
            byte[] fileContentTrackedByCommit = blobs.get(entry.getKey());
            writeContents(join(CWD, fileName), fileContentTrackedByCommit);
        }

        /* Rollback branches, then update the branch
        serialized file in heads/ dir and branches/ dir.
         */
        writeObject(join(GIT_HEADS_DIR, currentBranchName), concreteCommit);
        writeObject(join(GIT_BRANCH_DIR, currentBranchName), concreteCommit);

        // clear stage Area after branch checkout.
        stageForAddition = readObject(GIT_STAGE_FOR_ADD, TreeMap.class);
        stageForAddition.clear();
        writeObject(GIT_STAGE_FOR_ADD, stageForAddition);
    }

    @SuppressWarnings("unchecked")  // ignore warning
    public static void merge(String branchName) {
        String currBranchName = plainFilenamesIn(GIT_HEADS_DIR).get(0);
        List<String> branchNames = plainFilenamesIn(GIT_BRANCH_DIR);
        blobs = readObject(GIT_BLOB, TreeMap.class);
        stageForRemoval = readObject(GIT_STAGE_FOR_REMOVE, TreeMap.class);
        stageForAddition = readObject(GIT_STAGE_FOR_ADD, TreeMap.class);
        List<String> workingDirFiles = plainFilenamesIn(CWD);
        for (String fileName : workingDirFiles) {
            File concreteFile = join(CWD, fileName);
            // Untracked file will be written.
            String blobId = sha1(fileName, readContents(concreteFile));
            if (!(blobs.containsKey(blobId) || stageForAddition.containsKey(blobId))) {
                System.out.println("There is an untracked file in the way;"
                        + "delete it, or add and commit it first.");
                System.exit(0);
            }
        }
        if (!stageForAddition.isEmpty() || !stageForRemoval.isEmpty()) {
            System.out.println("You have uncommitted changes.");
            System.exit(0);
        }
        if (!branchNames.contains(branchName)) {
            System.out.println("A branch with that name does not exist.");
            System.exit(0);
        }
        if (currBranchName.equals(branchName)) {
            System.out.println("Cannot merge a branch with itself.");
            System.exit(0);
        }
        Commit currBranch = readObject(join(GIT_BRANCH_DIR, currBranchName), Commit.class);
        Commit givenBranch = readObject(join(GIT_BRANCH_DIR, branchName), Commit.class);
        // If find split point, it will return the object otherwise return null.
        Commit splitPoint = findSplitPoint(currBranch, givenBranch);
        // test
        if (splitPoint == null) {
            System.out.println("Does not find split point.");
            System.exit(0);
        }
        // If the split point is the same commit as the given branch, then we do nothing
        if (splitPoint.getOwnRef().equals(givenBranch.getOwnRef())) {
            System.out.println("Given branch is an ancestor of the current branch.");
            System.exit(0);
        }
        if (splitPoint.getOwnRef().equals(currBranch.getOwnRef())) {
            String[] command = {"checkout", branchName};
            System.out.println("Current branch fast-forwarded.");
            checkout(command);
            System.exit(0);
        }
        // Get tracked blobs mapping <BlobId, Content>.
        TreeMap<String, byte[]> currBranchTracks = new TreeMap<>();
        TreeMap<String, byte[]> givenBranchTracks = new TreeMap<>();
        TreeMap<String, byte[]> splitPointTracks = new TreeMap<>();
        for (Map.Entry<String, byte[]> entry : blobs.entrySet()) {
            if (currBranch.getTrack().containsKey(entry.getKey())) {
                currBranchTracks.put(entry.getKey(), entry.getValue());
            }
            if (givenBranch.getTrack().containsKey(entry.getKey())) {
                givenBranchTracks.put(entry.getKey(), entry.getValue());
            }
            if (splitPoint.getTrack().containsKey(entry.getKey())) {
                splitPointTracks.put(entry.getKey(), entry.getValue());
            }
        }
        judgeMergeCase(currBranch, givenBranch, splitPoint, givenBranchTracks);
        writeObject(GIT_STAGE_FOR_ADD, stageForAddition);
        writeObject(GIT_BLOB, blobs);
        String commitMessage = "Merged " + branchName + " into " + currBranchName + ".";
        commitMerge(commitMessage, givenBranch.getOwnRef());
    }

    public static void judgeMergeCase(Commit currBranch,
                                      Commit givenBranch,
                                      Commit splitPoint,
                                      TreeMap<String, byte[]> givenBranchTracks) {
        // <BlobId, FileName>
        TreeMap<String, String> currBranchFileNameTracks = currBranch.getTrack();
        TreeMap<String, String> givenBranchFileNameTracks = givenBranch.getTrack();
        TreeMap<String, String> splitPointFileNameTracks = splitPoint.getTrack();
        List<String> allFileNames = new ArrayList<>();
        boolean conflict = false;
        getAllFileNames(currBranchFileNameTracks, givenBranchFileNameTracks,
                splitPointFileNameTracks, allFileNames);
        for (String fileName : allFileNames) {
            // If the file does not exist, the blobId will be empty string.
            String currBlobId = getBlobId(currBranchFileNameTracks, fileName);
            String givenBlobId = getBlobId(givenBranchFileNameTracks, fileName);
            String splitBlobId = getBlobId(splitPointFileNameTracks, fileName);
            boolean currIsPresent = currBranchFileNameTracks.containsValue(fileName);
            boolean givenIsPresent = givenBranchFileNameTracks.containsValue(fileName);
            boolean splitPointIsPresent = splitPointFileNameTracks.containsValue(fileName);
            boolean currModified = false;
            boolean givenModified = false;
            if (!currBlobId.equals(splitBlobId)) {
                currModified = true;
            }
            if (!givenBlobId.equals(splitBlobId)) {
                givenModified = true;
            }
            if (!currModified && givenModified
                    && currIsPresent && givenIsPresent && splitPointIsPresent) {
                // Case 1
                stageForAddition.put(givenBlobId, fileName);
                writeContents(join(CWD, fileName), givenBranchTracks.get(givenBlobId));
            } else if (currModified && !givenModified
                    && currIsPresent && givenIsPresent && splitPointIsPresent) {
                // Case 2
                stageForAddition.put(currBlobId, fileName);
            } else if (currModified && givenModified) {
                // case 3
                // same ways, Do Not Modified(same)
                if (!currBlobId.equals(givenBlobId)) {
                    // diff ways, Conflict
                    conflict = true;
                    String currContents = currBlobId.equals("") ? ""
                            : new String(blobs.get(currBlobId));
                    String givenContents = givenBlobId.equals("") ? ""
                            : new String(blobs.get(givenBlobId));
                    String conflictContents = "<<<<<<< HEAD\n"
                            + currContents + "=======\n" + givenContents + ">>>>>>>\n";
                    // modified this file.
                    byte[] conflictContentsByte = conflictContents.getBytes();
                    String newBlobId = sha1(fileName, conflictContentsByte);
                    stageForAddition.put(newBlobId, fileName);
                    blobs.put(newBlobId, conflictContentsByte);
                    writeContents(join(CWD, fileName), conflictContentsByte);
                }
            } else if (!splitPointIsPresent && !givenIsPresent && currIsPresent) {
                // case 4
                stageForAddition.put(currBlobId, fileName);
            } else if (!splitPointIsPresent && !currIsPresent && givenIsPresent) {
                stageForAddition.put(givenBlobId, fileName);
                writeContents(join(CWD, fileName), givenBranchTracks.get(givenBlobId));
                // case 5
            } else if (!currModified && !givenIsPresent) {
                // case 6
                rm(fileName);
//            } else if (!givenModified && !currIsPresent) {  // Not need to handle it.
            }
        }
        if (conflict) {
            System.out.println("Encountered a merge conflict.");
        }
    }

    public static String getBlobId(TreeMap<String, String> tracks, String fileName) {
        for (Map.Entry<String, String> entry : tracks.entrySet()) {
            String name = entry.getValue();
            if (fileName.equals(name)) {
                return entry.getKey();
            }
        }
        return "";
    }

    public static void getAllFileNames(TreeMap<String, String> currTracks,
                                       TreeMap<String, String> givenTracks,
                                       TreeMap<String, String> splitPointTracks,
                                       List<String> allFileNames) {
        for (Map.Entry<String, String> entry : currTracks.entrySet()) {
            String fileName = entry.getValue();
            if (!allFileNames.contains(fileName)) {
                allFileNames.add(fileName);
            }
        }
        for (Map.Entry<String, String> entry : givenTracks.entrySet()) {
            String fileName = entry.getValue();
            if (!allFileNames.contains(fileName)) {
                allFileNames.add(fileName);
            }
        }
        for (Map.Entry<String, String> entry : splitPointTracks.entrySet()) {
            String fileName = entry.getValue();
            if (!allFileNames.contains(fileName)) {
                allFileNames.add(fileName);
            }
        }
    }

    public static Commit findSplitPoint(Commit currBranch, Commit givenBranch) {
        List<String> currBranchPath = new ArrayList<>();
        Set<String> givenBranchPath = new HashSet<>();

        // Use BFS algorithm to traverse branch path.
        Queue<Commit> que = new LinkedList<>();
        que.add(currBranch);
        while (!que.isEmpty()) {
            Commit element = que.poll();  // Get the head element of queue head.
            currBranchPath.add(element.getOwnRef());  // Add commit alongside the path to the List.
            if (element.getParentRef() != null) {
                Commit parent = readObject(join(GIT_OBJECTS_DIR, element.getParentRef()),
                        Commit.class);
                que.add(parent);
            }
            if (element.getSecondParentRef() != null) {
                Commit parent = readObject(join(GIT_OBJECTS_DIR, element.getSecondParentRef()),
                        Commit.class);
                que.add(parent);
            }
        }

        que.add(givenBranch);
        while (!que.isEmpty()) {
            Commit element = que.poll();  // Get the head element of queue head.
            givenBranchPath.add(element.getOwnRef());  // Add commit alongside the path to the sets.
            if (element.getParentRef() != null) {
                Commit parent = readObject(join(GIT_OBJECTS_DIR, element.getParentRef()),
                        Commit.class);
                que.add(parent);
            }
            if (element.getSecondParentRef() != null) {
                Commit parent = readObject(join(GIT_OBJECTS_DIR, element.getSecondParentRef()),
                        Commit.class);
                que.add(parent);
            }
        }

        // Find split point.
        for (String ref : currBranchPath) {
            if (givenBranchPath.contains(ref)) {
                // find
                return readObject(join(GIT_OBJECTS_DIR, ref), Commit.class);
            }
        }
        return null;
    }


}
